import os
import sys
import time

try:
    import pandas as pd
except ImportError:
    pd = None

# ===========================
#  全局默认配置
# ===========================
DEFAULT_CONFIG = {
    "target_pkg": "cn.net.cloudthink.smartmirror",
    "duration_sec": 86400 * 3,
    "start_activity": ".MainActivity"
}


class StressCompiler:
    def __init__(self, target_pkg, duration=3600, start_uri=None):
        self.target_pkg = target_pkg
        self.duration = int(duration)
        if "/" in str(start_uri):
            self.start_uri = start_uri
        else:
            self.start_uri = f"{target_pkg}/{start_uri}"

    # [修复] 缩进修复：之前缩进过多导致变成了 __init__ 的内部函数
    def compile_sequence(self, plan_list):
        shell = f"""#!/system/bin/sh
    # Auto-generated by Dognoise Compiler (Kiwi Optimized)
    # Target: {self.target_pkg}

    MY_PID=$$
    LOCK_FILE="/data/local/tmp/dognoise.lock"

    # 简单的单例锁
    if [ -f "$LOCK_FILE" ]; then
        OLD_PID=$(cat "$LOCK_FILE")
        if [ -d "/proc/$OLD_PID" ]; then
            kill -9 $OLD_PID > /dev/null 2>&1
        fi
    fi
    echo $MY_PID > $LOCK_FILE

    LOG_DIR="/sdcard/dognoise_stress"
    mkdir -p $LOG_DIR
    EVENT_LOG="$LOG_DIR/event.log"
    CRASH_LOG="$LOG_DIR/crash_stack.log"
    ANR_LOG="$LOG_DIR/anr_history.log"
    touch $EVENT_LOG $CRASH_LOG $ANR_LOG

    # 日志头
    echo "=== Long-Term Stress Test Start: $(date) ===" > $EVENT_LOG
    echo "Target: {self.target_pkg}" >> $EVENT_LOG
    echo "Script Version: Optimized Loop & Mem Check" >> $EVENT_LOG

    # 环境准备
    svc power stayon true
    logcat -c
    # 抓取 Crash (Info级别)
    nohup logcat -v time *:I -f $CRASH_LOG -r 10240 -n 50 &
    LOGCAT_PID=$!

    start_time=$(date +%s)
    last_heavy_check_time=0
    sysui_pid=$(pidof com.android.systemui)

    # --- 函数定义 ---

    function take_snapshot() {{
        local type_name=$1
        local time_str=$(date +%Y%m%d_%H%M%S)
        screencap -p "$LOG_DIR/${{type_name}}_${{time_str}}.png"
        echo "    [SNAPSHOT] ${{type_name}}" >> $EVENT_LOG
    }}

    function perform_heavy_check() {{
        local now_ts=$(date +%s)

        # 1. 检查 ANR (轻量级)
        if logcat -b events -d -t 200 | grep -q "am_anr"; then
            if logcat -b events -d -t 200 | grep "am_anr" | grep -q "{self.target_pkg}"; then
                 echo "!!! [$(date)] [ANR_DETECTED] !!!" >> $EVENT_LOG
                 echo "--- ANR Logged at $(date) ---" >> $ANR_LOG
                 take_snapshot "ANR"
                 am force-stop {self.target_pkg}
                 logcat -b events -c 
                 sleep 2
                 am start -n {self.start_uri}
                 sleep 5
                 return
            fi
        fi

        # 2. 检查 SystemUI 重启
        local curr_sysui=$(pidof com.android.systemui)
        if [ "$curr_sysui" != "$sysui_pid" ]; then
            echo "!!! [$(date)] [SYSTEM_CRASH] SystemUI PID Changed ($sysui_pid -> $curr_sysui)" >> $EVENT_LOG
            take_snapshot "SYS_CRASH"
            sysui_pid=$curr_sysui
        fi

        # 3. 焦点检查
        local current_focus=$(dumpsys window | grep mCurrentFocus)
        if ! echo "$current_focus" | grep -q "{self.target_pkg}"; then
            echo "    [WARN] 焦点丢失/应用在后台，尝试拉起..." >> $EVENT_LOG
            am start -n {self.start_uri}
        fi

        # 4. [优化] 极速内存检查 (读取 /proc/pid/status 替代 dumpsys)
        local app_pid=$(pidof {self.target_pkg})
        if [ ! -z "$app_pid" ]; then
            # VmRSS 代表物理内存占用 (kB)
            local mem_kb=$(grep VmRSS /proc/$app_pid/status 2>/dev/null | awk '{{print $2}}')
            if [ ! -z "$mem_kb" ]; then
                local mem_mb=$((mem_kb / 1024))
                echo "[STATUS] $(date "+%Y-%m-%d %H:%M:%S") | Mem:${{mem_mb}}MB" >> $EVENT_LOG
            fi
        fi

        last_heavy_check_time=$now_ts
    }}

    function check_health_fast() {{
        # 1. 进程存活 (pidof 极快)
        if [ -z "$(pidof {self.target_pkg})" ]; then
            echo "!!! [$(date)] [DIED] 进程消失 !!!" >> $EVENT_LOG
            take_snapshot "DIED"
            am start -n {self.start_uri}
            sleep 5
            return
        fi

        # 2. 节流执行重型检查 (30秒一次)
        local current_ts=$(date +%s)
        local diff=$((current_ts - last_heavy_check_time))
        if [ $diff -ge 30 ]; then
            perform_heavy_check
        fi
    }}

    # --- 主循环 ---
    while [ $(($(date +%s) - start_time)) -lt {self.duration} ]; do

    """
        # 任务循环部分
        for plan in plan_list:
            sheet_name = plan['name']
            sheet_loop = plan['loop']
            tasks = plan['tasks']

            shell += f"\n    # >>> {sheet_name} <<<\n"
            # [优化] 使用 while 循环替代 $(seq)，避免循环次数极大时报错 "Argument list too long"
            shell += f"    count_{sheet_name}=0\n"
            shell += f"    while [ $count_{sheet_name} -lt {sheet_loop} ]; do\n"
            shell += f"        count_{sheet_name}=$((count_{sheet_name} + 1))\n"

            for task in tasks:
                if pd.isna(task.get('action')): continue
                action = str(task.get('action')).upper().strip()
                seq_id = task.get('seq')
                indent = "        "

                # 1. 健康检查
                shell += f"{indent}check_health_fast\n"

                # 2. 记录动作 (去除耗时操作)
                shell += f'{indent}echo "[$(date "+%Y-%m-%d %H:%M:%S")] [{sheet_name}][#{seq_id}] {action}" >> $EVENT_LOG\n'

                if action == "CLICK":
                    shell += f"{indent}input tap {task.get('p1')} {task.get('p2')}\n"
                elif action == "SWIPE":
                    shell += f"{indent}input swipe {task.get('p1')} {task.get('p2')} {task.get('p3')} {task.get('p4')} 300\n"
                elif action == "KEY":
                    shell += f"{indent}input keyevent {task.get('p1')}\n"
                elif action == "TEXT":
                    # [优化] 处理空格和单引号转义，防止脚本语法错误
                    raw_txt = str(task.get('p1'))
                    txt = raw_txt.replace(" ", "%s").replace("'", "'\\''")
                    shell += f"{indent}input text '{txt}'\n"
                elif action == "WAIT":
                    wait_time = task.get('p1') if pd.notna(task.get('p1')) else 1
                    shell += f"{indent}sleep {wait_time}\n"
                elif action == "STOP":
                    shell += f"{indent}am force-stop {self.target_pkg}\n"
                elif action == "START":
                    shell += f"{indent}am start -n {self.start_uri}\n"
                elif action == "SHELL":
                    shell += f"{indent}{task.get('p1')}\n"

            shell += f"    done\n"

        shell += """
        sleep 1
    done

    echo "=== End: $(date) ===" >> $EVENT_LOG
    rm "$LOCK_FILE"
    kill $LOGCAT_PID
    """
        return shell


def load_project_config(excel_path):
    config = DEFAULT_CONFIG.copy()
    sequence_plan = []

    try:
        # 读取配置 Key-Value
        df_kv = pd.read_excel(excel_path, sheet_name='Config', usecols=[0, 1], header=None)
        cfg_dict = dict(zip(df_kv.iloc[:, 0], df_kv.iloc[:, 1]))

        if 'target_pkg' in cfg_dict and pd.notna(cfg_dict['target_pkg']):
            config['target_pkg'] = str(cfg_dict['target_pkg']).strip()
        if 'start_activity' in cfg_dict and pd.notna(cfg_dict['start_activity']):
            config['start_activity'] = str(cfg_dict['start_activity']).strip()

        # 时长解析逻辑
        if 'duration_value' in cfg_dict and pd.notna(cfg_dict['duration_value']):
            try:
                val = float(cfg_dict['duration_value'])
                unit = str(cfg_dict.get('duration_unit', 'sec')).lower()
                if 'day' in unit or '天' in unit:
                    config['duration_sec'] = int(val * 86400)
                elif 'hour' in unit or '时' in unit:
                    config['duration_sec'] = int(val * 3600)
                elif 'min' in unit or '分' in unit:
                    config['duration_sec'] = int(val * 60)
                else:
                    config['duration_sec'] = int(val)
            except ValueError:
                print("时长配置格式错误，使用默认值")

        # 解析 Sheet 列表
        print(" 解析excel...")
        df_full = pd.read_excel(excel_path, sheet_name='Config')

        seq_col = next((c for c in df_full.columns if "执行顺序" in str(c) or "Sheet" in str(c)), None)
        loop_col = next((c for c in df_full.columns if "本轮循环" in str(c) or "Loop" in str(c)), None)

        if seq_col:
            plan_df = df_full[[seq_col, loop_col]].dropna(subset=[seq_col])
            for _, row in plan_df.iterrows():
                s_name = str(row[seq_col]).strip()
                if s_name in ["执行顺序", "Sheet Name", "nan"]: continue
                try:
                    l_count = int(row[loop_col])
                except:
                    l_count = 1
                sequence_plan.append({"name": s_name, "loop": l_count})

    # [优化] 增加 Excel 文件占用的捕获
    except PermissionError:
        print(f"错误: 无法读取 '{excel_path}'")
        print("   原因: 文件可能被 Excel/WPS 打开并锁定。")
        print("   解决: 请关闭文件后重试！")
        sys.exit(1)
    except Exception as e:
        print(f"配置读取失败: {e}")
        sys.exit(1)

    return config, sequence_plan


def parse_tasks_from_sheet(excel_path, sheet_name, global_seq_start):
    try:
        df = pd.read_excel(excel_path, sheet_name=sheet_name)
    except Exception as e:
        print(f"无法读取 Sheet [{sheet_name}]: {e}")
        return [], global_seq_start

    tasks = []
    current_seq = global_seq_start
    cols = df.columns

    def find_col(keywords):
        for c in cols:
            if any(k in str(c) for k in keywords):
                return c
        return None

    col_action = find_col(['指令', 'Action'])
    col_repeat = find_col(['重复', 'Repeat'])
    col_p1 = find_col(['参数1', 'P1'])
    col_p2 = find_col(['参数2', 'P2'])
    col_p3 = find_col(['参数3', 'P3'])
    col_p4 = find_col(['参数4', 'P4'])

    if not col_action:
        print(f"Sheet [{sheet_name}] 找不到 '指令' 列，跳过。")
        return [], global_seq_start

    for index, row in df.iterrows():
        act = row.get(col_action)
        if pd.isna(act): continue

        try:
            repeat_count = int(row.get(col_repeat, 1))
        except:
            repeat_count = 1
        if repeat_count < 1: repeat_count = 1

        for i in range(repeat_count):
            current_seq += 1
            tasks.append({
                "seq": current_seq,
                "action": act,
                "p1": row.get(col_p1),
                "p2": row.get(col_p2),
                "p3": row.get(col_p3),
                "p4": row.get(col_p4),
            })

    return tasks, current_seq


if __name__ == "__main__":

    if pd is None:
        print("错误: 需安装 pandas openpyxl")
        sys.exit(1)

    current_dir = os.path.dirname(os.path.abspath(__file__))
    EXCEL_FILE = os.path.join(current_dir, "test plan.xlsx")
    OUTPUT_DIR = os.path.join(current_dir, "dist_stress")

    if not os.path.exists(EXCEL_FILE):
        print(f"找不到配置文件: {EXCEL_FILE}")
        sys.exit(1)

    final_config, seq_plan = load_project_config(EXCEL_FILE)

    if not seq_plan:
        print("Config Sheet 未指定顺序，尝试自动扫描...")
        xl = pd.ExcelFile(EXCEL_FILE)
        for s in xl.sheet_names:
            if s.lower().startswith("round") or s.lower() == "main":
                seq_plan.append({"name": s, "loop": 1})

    if not seq_plan:
        print("错误: 无法构建执行计划。")
        sys.exit(1)

    print(f"目标应用: {final_config['target_pkg']}")

    full_execution_plan = []
    global_seq_counter = 0

    for stage in seq_plan:
        s_name = stage['name']
        s_loop = stage['loop']
        stage_tasks, new_seq = parse_tasks_from_sheet(EXCEL_FILE, s_name, global_seq_counter)
        global_seq_counter = new_seq
        if stage_tasks:
            full_execution_plan.append({"name": s_name, "loop": s_loop, "tasks": stage_tasks})
            print(f"   -> Sheet [{s_name}]: {len(stage_tasks)} 动作 / {s_loop} 循环")

    compiler = StressCompiler(
        target_pkg=final_config['target_pkg'],
        duration=final_config['duration_sec'],
        start_uri=final_config['start_activity']
    )
    shell_code = compiler.compile_sequence(full_execution_plan)

    if not os.path.exists(OUTPUT_DIR):
        os.makedirs(OUTPUT_DIR)

    sh_path = os.path.join(OUTPUT_DIR, "stress_core.sh")
    with open(sh_path, "w", encoding="utf-8", newline='\n') as f:
        f.write(shell_code)

    bat_content = f"""@echo off
title Dognoise Stress Launcher
color 0A
echo.
echo [Dognoise] 正在初始化环境...
adb wait-for-device
adb root
adb remount

echo.
echo [1/3] 正在清理旧的压测进程 (防止冲突)...
echo ------------------------------------------
adb shell "pkill -f stress_core.sh"
adb shell "killall stress_core.sh >/dev/null 2>&1"
adb shell "rm -f /data/local/tmp/dognoise.lock"
adb logcat -c && adb shell "rm -rf /sdcard/dognoise_stress/*"
echo ------------------------------------------

echo.
echo [2/3] 推送新脚本...
adb push stress_core.sh /data/local/tmp/stress_core.sh
adb shell chmod 777 /data/local/tmp/stress_core.sh

echo.
echo [3/3] 启动压测任务...
echo.
echo ------------------------------------------
echo 脚本已在后台启动。
echo 日志路径: /sdcard/dognoise_stress/event.log
echo ------------------------------------------
adb shell "nohup sh /data/local/tmp/stress_core.sh > /dev/null 2>&1 &"

echo.
echo 启动成功！
pause
"""
    bat_path = os.path.join(OUTPUT_DIR, "一键开始压测.bat")
    with open(bat_path, "w", encoding="gbk") as f:
        f.write(bat_content)

    print(f"\n✅ 编译完成！目录: {OUTPUT_DIR}")
    print(f"   请务必运行 [一键开始压测.bat]")